snippet userc
use std::cell::RefCell;
use std::rc::Rc;
${0}
endsnippet

snippet usefs
use std::fs;
${0}
endsnippet

snippet ifls
if let Some($1) = $2 {
    $0
}
endsnippet

snippet msome
match $1 {
    None => {},
    Some(v) => {
    }
}
endsnippet

snippet dis
#[cfg(disable)]
endsnippet

snippet struct
struct $1 {
}

impl $1 {
    fn new() -> Self {
        Self {
	    $0
        }
    }
}
endsnippet

snippet fnew
fn new() -> Self {
    Self {
        $0
    }
}
endsnippet

snippet ifrom
impl From<$1> for $2 {
    fn from(v: $1) -> Self { $2::$3(v) }
}
endsnippet

snippet idebug
impl std::fmt::Debug for $1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "$1 {{ }}")
    }
}
endsnippet

snippet fnms
fn $1(&mut self) {
    $0
}
endsnippet

snippet fns
fn $1(&self) {
    $0
}
endsnippet

snippet dernum
#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
$0
endsnippet

snippet script
#!/usr/bin/env run-cargo-script

fn main() {
    $0
}
endsnippet

snippet fnS
fn $1(self) {
    $0
}
endsnippet

snippet testmod "" m
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn main() {
        $0
    }
}
endsnippet

snippet unsimport
#![allow(unused_imports)]
endsnippet

snippet unused
#[allow(unused)] // TODO
endsnippet

snippet unimpl "" m
$0

unimplemented!();
endsnippet

snippet pan "" m
panic!();
$0
endsnippet

snippet alldead
#![allow(dead_code, unused_imports)] // REMOVE ME
endsnippet

snippet portablefn "" m
#[cfg(target_os = "linux")]
pub fn $1 {
    $0
}

#[cfg(any(target_os = "macos", target_os = "freebsd", target_os = "openbsd", target_os = "netbsd"))]
pub fn $1 {
}

#[cfg(target_os = "windows")]
pub fn $1 {
}
endsnippet

snippet hashmap_entry
use std::collections::hash_map;
let mut item = match $1.entry($2) {
    hash_map::Entry::Vacant(v) => v.insert($3),
    hash_map::Entry::Occupied(o) => o.into_mut(),
};
endsnippet

snippet btreemap_entry
use std::collections::btree_map;
let mut item = match $1.entry($2) {
    btree_map::Entry::Vacant(v) => v.insert($3),
    btree_map::Entry::Occupied(o) => o.into_mut(),
};
endsnippet


snippet bigstructopt
extern crate structopt;
#[macro_use]
extern crate structopt_derive;

use structopt::StructOpt;
use structopt::clap::AppSettings;

#[derive(Debug, StructOpt)]
pub struct Server {
    #[structopt(name = "server_addr", short="s")]
    pub server_addr: Option<String>,

    #[structopt(name = "server_port", short="p", default_value="3232")]
    pub server_port: u16,
}

#[derive(Debug, StructOpt)]
pub struct Client {
    #[structopt(name = "server_addr")]
    pub server_addr: String,

    #[structopt(name = "server_port", short="p", default_value="3232")]
    pub server_port: u16,
}


#[derive(Debug, StructOpt)]
pub enum Command {
    #[structopt(name = "server")]
    Server(Server),

    #[structopt(name = "client")]
    Client(Client),
}

#[derive(StructOpt, Debug)]
#[structopt(raw(global_settings = "&[AppSettings::ColoredHelp, AppSettings::VersionlessSubcommands]"))]
pub struct Opt {
    #[structopt(subcommand)]
    command: Command,
}

fn main() -> Result<(), ()> {
    let opt = Opt::from_args();
    // Write me
}
endsnippet

snippet sep

///////////////////////////////////////////////////////////////////////////////
// $0
//

endsnippet
