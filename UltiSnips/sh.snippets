snippet if
if [[ ${0} ]] ; then
    echo ""
fi
endsnippet

snippet timestamped
(while [ 1 ] ; do echo command ; sleep 1; done) | awk '{ print strftime("\033[32m%Y-%m-%dT%H:%M:%S\033[0m"), $0 }'
endsnippet

snippet prelude
#!/bin/bash

set -eu
set -o pipefail
set +o posix
shopt -s inherit_errexit

main() {
    echo args: "$@"
}

main "$@"
endsnippet

snippet heredoc
cat > filename << EOF
${0}
EOF
endsnippet

snippet pipe-heredoc-tab
command <<- EOF
${0}
EOF
endsnippet

snippet trace
_trace_to_file() {
    export PS4='\$(date "+%Y.%m.%d-%H:%M:%S.%N") \${BASH_SOURCE}:\${FUNCNAME[0]:+\${FUNCNAME[0]}():}\${LINENO}: '
    exec 3<> \$1
    BASH_XTRACEFD=3
    set -x
}
endsnippet

snippet trace-pretty-stdout
PS4='\033[38;5;237m$(date "+%Y.%m.%d-%H:%M:%S.%N" | cut -c-23) \033[38;5;243m${BASH_SOURCE}\033[38;5;237m:${FUNCNAME[0]:+${FUNCNAME[0]}():}\033[38;5;243m${LINENO}\033[38;5;237m: \033[00m'
endsnippet

snippet rematch
if [[ "${arg}" =~ ^root=(.*)$ ]]; then
echo "${BASH_REMATCH[1]}"
fi
endsnippet

snippet arrayiter
local key
for key in "${!array[@]}"; do
    local value=${array[${key}]}
done
endsnippet

snippet argparse
local dryrun=1
local positional=()

while [[ $# != 0 ]] ; do
    if [[ "\$1" == "--real" ]] ; then
        dryrun=0
        shift
        continue
    fi
    positional+=(\$1)
    shift
done

local orig="${positional[0]}"
local new_base="${positional[1]}"
endsnippet

snippet argparse-elab
main-params-parse() {
    local _verbose=0
    local _debug=0

    while [[ \$# != 0 ]] ; do
        if [[ \$1 =~ ^-[a-zA-Z0-9]+\$ ]] ; then
	    for ((i=2;i<=\${#1};i++)); do # Iterate characters
	        local c=\${1:\$i-1:1}
	        case \${1:\$i-1:1} in
		    v) _verbose=1 ;;
		    d) _debug=1 ;;
		    *) echo "Invalid parameter \${c}" ; return -1 ;;
	        esac
	    done
	    shift
        elif [[ "\$1" == "--verbose" ]] ; then
	    _verbose=1
	    shift
	    continue
        elif [[ "\$1" == "--debug" ]] ; then
	    _debug=\$1
	    shift
	    continue
        fi
        break # Continue to positional arguments
    done

    verbose=\${_verbose}
    remaining_args=("\$@")
}

main-params-parse "\$@" # Outputs remaining_args
set +u ; set -- "\${remaining_args[@]}" ; set -u
endsnippet

snippet perline-parse
while read a b ; do
    echo ${a} ${b}
done < <(command)
endsnippet

snippet sigint
trap ctrl_c INT

function ctrl_c() {
    ${0}
}
endsnippet

snippet stderr
>&2 echo "error"
endsnippet

snippet tempdir
local tmp_dir=$(mktemp -d -t prefix-XXXXXXXXXX)
# Stuff
rm -rf ${tmp_dir}
endsnippet

snippet oldarrayeval
\${${1}[@]+"${${1}[@]}"}
endsnippet

snippet runscript
#!/bin/bash

set -eu
set -o pipefail
set +o posix

scriptdir=\$(realpath \$(dirname \${BASH_SOURCE}))

command() {
    local _output_path=""
    local positional=()

    while [[ $# != 0 ]] ; do
        if [[ "\$1" == "--output-path" ]] ; then
            _output_path="\$1"
            shift
            continue
        fi
	positional+=($1)
	shift
    done

    set -- "${positional[@]}"
}

help() {
    cat << EOF

Example:

    ${BASH_SOURCE} command
EOF
}

if [[ "$@" == "" ]] ; then
    help
else
    "$@"
fi
endsnippet

snippet clean-background-on-termination
function leave() {
    kill $(jobs -p)
    wait $(jobs -p) 2>/dev/null || true
}
trap leave EXIT
endsnippet

snippet runparameterized
#!/bin/bash

# export KEY=VAL

exec $(realpath $(dirname ${BASH_SOURCE}))/run "\$@"
endsnippet


snippet detached
run-detached() {
    tmp_dir_to_delete="\$1"
    shift

    function leave() {
        case ${tmp_dir_to_delete} in
            /tmp/*)
                rm -rf ${tmp_dir_to_delete}
                ;;
        esac
    }
    trap leave EXIT

    "$@"
}

detached() {
    # Copy the script aside and run it from tmp

    local tmp_dir=$(mktemp -d -t syslab-XXXXXXXXXX)
    cp ${BASH_SOURCE} ${tmp_dir}/syslab
    exec ${tmp_dir}/syslab run-detached ${tmp_dir} "$@"
}
endsnippet
